# 【課外学習 I】Gopher道場

* [【課外学習 I】Gopher道場](https://mercari.connpass.com/event/100508/)

## DDD の意味を知る

* DDD = ドメイン駆動設計
* ドメインで設計を駆動する
* ドメインとは
  * 問題領域
  * ソフトウェアを適用させる業務や関心ごと
* ソフトウェアを適用させる業務
  * 例: メルカリ
  * CtoC で物を売り買いする = メルカリのドメイン
* なぜソフトウェアを適用するか
  * 既存のものに何かしらの問題があるから
* 関心ごと
  * 全てか人がやっていたことを代わりにやらせるためにソフトウェアを使う訳ではない
    * Twitter とか
  * 業務ではないけど問題になっていること

* ドメイン = 業務
* ドメイン駆動設計 = 業務駆動設計

## DDD のメリット

* 業務で設計を駆動するメリット
* 既存の何かが抱えていた問題を解決するアプローチのはず
  * 既存の業務駆動じゃないアプローチとは？
* 既存のアプローチ = DOA (データ中心アプローチ)
  * 業務で扱うデータを ER モデルにし、その DB を中心に設計される
* DOA の特徴
  * DB の特性と目的に合わせたデータ設計になる
  * DB の特性
    * MySQL, Redis とかの差
  * 目的
    * Write は多いけど Read はされないみたいなの

* DB のデータ構造 = モデルのデータ構造
  * コードの可読性を落とす可能性がある
  * 業務上存在する概念をコード上で扱えない
 
どれがユーザのプロフィール更新で変更されるのかがわからない

```go
type UserAccount struct {
    id int
    pass string
    name string
    email string
    address string
}
```

ボスはランクで種類が管理される
特定のボスのみ Attack() できるという仕様だと実装がめんどい

```go
type Boss struct {
    id int
    name string
    rank string
}

func (b *Boss) Attack() {
}
```

* この場合は `BigBoss` と `MiddleBoss` みたいにモデルを分ける
  * 別々のモデルがあれば明確
  * DOA の場合はモデルを分けるとテーブルを分けないといけない
    * DB 構造的には分けない方が管理が楽
* DB の構造がプログラミングに適しているとは限らない
* DOA によって設計したデータ構造をそのままプログラムで扱うのが問題
* 可読性を下げるのはドメインとコードが乖離している状態
* 業務の理解とコードの理解の両方が必要で、両方知ってないと運用できない
  * ex. type, status, flg という謎のカラム

* DDD は DB の構造をプログラムで利用しない
* プログラムにはプログラムに適したデータ構造を利用する
* 業務とコードの乖離を可能な限り無くし、可読性をあげる
  * 業務を理解すればコードも理解できる状態
    * ユースケースレイヤ
  * 実装詳細に踏み込みやすいコードになる
    * インタフェースアダプタ
    * インフラストラクチャレイヤとか
* プログラムに適したデータ構造
  * 業務を反映したデータ構造 + 振る舞い
  * データ構造だけじゃなくて関数とかも業務に即した挙動にする

## 何をすれば DDD になるのか

* 分析
  * 業務をコードに落としこめるように分析する
  * レイヤ構造とリポジトリパターン適用したから DDD だみたいなのは分析をしていないので違う
* 設計
  * 分析結果をコードに落とし込むための設計をする
* 実装
  * 実装する
* DDD では大きく戦略 + 戦術で分ける
  * これらのどれかがかけると DDD にはならない
* とくに戦略(分析, 設計) が大事
* 戦術のみ適用させる == 軽量 DDD
  * DDD においてはアンチパターン
  * 業務で設計を駆動できていない
* 分析->設計->実装を通して初めて DDD になる
  * そもそもスケールが大きすぎるので具体的にどうやるかを説明するのは困難
  * 本質的に手法は問わない
  * ドメインで設計を駆動できたらそれは DDD

## DDD のデメリット

* 学習コスト
* 分析コスト
* 実際可読性が上がるのかはわからない
  * 分析 + 設計に失敗するとやばい
  * 効果が出る(わかる)のは実装中になることがおおい
* モデル と DB のデータ構造が異なる
* そもそも難易度が高い
* DDD で解決できないこと
  * 業務の複雑さに伴うコードの複雑さ
  * 実装者の設計スキルが低いと可読性は落ちる

## DDD の必要性

* DDD が適してないケースも存在する
  * DB のデータ構造がプログラムに適している
    * ex. 単一概念の CRUD のみ提供する
  * 業務とコードの乖離が問題にならない
    * ex. 保守しない, 業務が単純
* 軽量 DDD は DDD ではないが単なる実装パターンとしては優秀
* 軽量 DDD でも解決できる問題はある
  * DDD にこだわる必要はない

## Go と DDD の相性

### Go で DDD は可能なのか

* 言語に縛られるものではないので可能
* フレームワークとかライブラリに依存することがおおい
  * モデルと DB 構造が 1:1 であるフレームワークとか
  * ドメインレイヤを他の DB とかから隔離できるか

### Go と DDD の相性はいいのか

* 絶対評価と相対評価
  * 絶対評価はわからん！
  * 相対評価
    * Java に比べるとって話を以下でする
* ORM 問題
  * DB とのデータ構造の乖離
  * Go は ORM でいい感じにしてくれることはできない
  * Java だといい感じにできるやつがある
* アノテーションベースの AOP
  * Go ではとくにない
* 情報量
  * Go で実践してる人があまりいない
    * 実装例がない
    * 聞く人がいない
    * Java, Scara 界隈が強い

## マイクロサービスと相性がいいのか

* いいといえばいいのかもしれない
* 境界づけられたコンテキストはマイクロサービスのサービス分割にちょうどよさそう
* DDD の実装が相性がいいのかどうかは業務の要件次第感
